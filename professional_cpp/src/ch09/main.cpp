module;
// #include <stdexcept>             // 很难理解，加上这句后，编译的时候 sc.getString() ： undefined reference to `SpreadsheetCell@spreadsheet_cell::getString[abi:cxx11]() const'
                        // 删除后，out_of_range 没有错误， 说明在 import spreadsheet 中导入进来了。
                // 可能导入后再导入会出问题？   但是 我用 #include <iostream> 没有问题。
            // 可能是因为其他文件 没有导入过 iostream。 。 stdexcept 在 Spreadsheet.cpp 中导入过。 不知道是不是 重复导入导致的问题。
#include <iostream>
#include <string>

export module main;     // global module fragment contents must be from preprocessor inclusion
        // https://en.cppreference.com/w/cpp/language/modules
        // Then, only preprocessing directives can appear in the global module fragment.
        // Then, a standard module declaration marks the end of the global module fragment and the start of the module content.
    // 没看懂，但是 给的代码示例中 有 export module A； 所以加了一个 就可以了。
    // 就是 如果有 第一行的 module; 那么就 需要 有这3样： #include <header-file>    export module XXX;   import <xxx>

// import <iostream>;
// import <format>;
// imoprt <stdexcept>;
// import <string>;     // ok
// import <string_view>;
import spreadsheet;
// import spreadsheet_cell;



    // install module (to this project)
    // g++ -std=c++20 -fmodules-ts -xc++-system-header     iostream

    // compile
// g++ -fmodules-ts SpreadsheetCell.cpp Spreadsheet.cpp main.cpp -std=c++20
// 只需要 所有的 实现的cpp文件， 不需要定义的 cc 文件。
// 只有 main.cpp的话，会报错，undefined reference to `Spreadsheet@spreadsheet::Spreadsheet(unsigned long, unsigned long)
// cao . 不带 .cc 的话， 是无法更新 接口的， 所以 编译来，编译去， 就是说 没有成员  .. 直接疯了。
/*
main.cpp:43:19: 错误：‘class Spreadsheet@spreadsheet’ has no member named ‘asdd’
   43 |     std::cout<<s1.asdd<<std::endl;
*/

// g++ -fmodules-ts SpreadsheetCell.cc Spreadsheet.cc SpreadsheetCell.cpp Spreadsheet.cpp main.cpp -std=c++20
//
// 所以， 接口信息 被缓存在哪里？。  只有一个 main.cpp 的话，会报错 undefined reference。 带上所有的 cpp 就可以了。
// 但是， 不带cc 的话， 是无法更新接口的。 就是 cc的修改， main 不会知道。
// 是的。 cpp + cc， 在cc文件中增加 qqq。 main 输出 是可以的。
//       cpp + cc， cc，main 都 删除qqq， 编译ok
//       只有cpp， main,cc中增加qqq, 编译失败。
//       只有cpp， main删除qqq， 编译ok。
    // 每一步是在上一步的基础上改的。
    // 应该是 cache 在 gcm.cache/spreadsheet.gcm 中。   二进制。。 就是类似 二进制接口。
    //      所以 所有的 方法 ，编译的时候，看的是  gcm.cache 中的 接口。
    //          链接的时候 才会真正 链接到 实现上。  没有cache实现，所以 必须提供实现。



// move
void handleMsg(std::string& msg)
{
    std::cout<<" lvalue "<<msg<<std::endl;
}
void handleMsg2(std::string&& msg)
{
    std::cout<<"2222 r value"<<std::endl;
}
void handleMsg(std::string&& msg)
{
    // std::cout<<" rrrr";
    // std::cout<<msg;
    std::cout<<" rvalue "<<msg<<std::endl;
    std::cout<<"... "<<&msg<<std::endl;
    handleMsg2(std::move(msg));         // 必须 move， msg 它自己是 lvalue (可以取地址)， （它的内容是 rvalue）
}


int main()
{



    std::cout<<"1hello,world"<<std::endl;




    // https://labs.epubit.com/articleDetails?id=Nb5fe85e1-3a32-4809-9ae4-84bb29c979a4
    // coredumpctl gdb 进入最近一次coredump
    // 看信息，确实是 string的错误。但是我不知道 为什么会访问 一个无法访问的地址。 估计没戏。
// Core was generated by `./a.out'.
// Program terminated with signal SIGSEGV, Segmentation fault.
// #0  0x00000000004035f4 in std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_Alloc_hider::_Alloc_hider (this=0x0,
//     __dat=0x10 <error: Cannot access memory at address 0x10>, __a=...)
//     at /usr/include/c++/13/bits/basic_string.h:189
// 189		: allocator_type(__a), _M_p(__dat) { }

    // 在 single_test 中可以 a+b

    std::string a = "asd";
    handleMsg(a);               // l value
    // // std::string b {"zzz"};
    // std::string b = "zzz";
    // std::cout<<"1234"<<std::endl;
    // // try {
    // std::string c = a + b;          // 问题出在这个 a + b 上。。。  #include <string> 也不行。
    // // } catch (...) {
    // //     // e.what()
    // // }
    // std::cout<<c<<std::endl;
    // std::cout<<a+b<<std::endl;
    // handleMsg(a + b);        // .. 直接 段错误（核心已转储）， 里面的 cout 一个都没有
    handleMsg("zxcv");      // ok       r value
    handleMsg(std::move(a));        // r

    // int& aaa {1};    // non-const lvalue reference cannot xxxxx
    const int& aa3 {2};
    int&& aaa2 {111};
    std::cout<<"    "<<aa3<<", "<<aaa2<<std::endl;



    Spreadsheet s1 { 4,3 };

    // std::cout<<std::format("{}", 1);             // ? 不能用 format，不然报错，可以import <format>。
/*
/usr/include/c++/13/format:3614:7:   required from here
/usr/include/c++/13/bits/locale_classes.tcc:200:60: 编译器内部错误：在 tsubst_copy 中，于 cp/pt.cc:17288
  200 |       if (const _Facet* __f = std::__try_use_facet<_Facet>(__loc))
*/

    std::cout<<&s1<<std::endl;

    SpreadsheetCell sc {1.1};
    std::cout<<&sc<<std::endl;

    sc.setString("1.23");
    std::cout<<sc.getString()<<std::endl;

    // std::cout<<s1.asdd<<std::endl;
    // std::cout<<s1.qwe()<<std::endl;
    // std::cout<<s1.qqq<<std::endl;
    // std::cout<<s1.asd()<<std::endl;
    // std::cout<<&(s1.getCellAt(0,0))<<std::endl;

    try {
        std::cout<<"111"<<std::endl;
        s1.getCellAt(123123,123123);
        std::cout<<"222"<<std::endl;
    // } catch (...) {
    // } catch(std::out_of_range& e) {
    } catch (const std::logic_error& e) {   // class out_of_range : public logic_error
        std::cout<<"error,123123 123123\n";
        std::cout<<e.what()<<std::endl;
    }



    Spreadsheet s2 = s1;
    Spreadsheet s3 {s1};
    Spreadsheet s4 (s1);
    // 上面3条语句的输出： 构造，拷贝构造，构造，拷贝构造，构造，拷贝构造。

    s2 = s3;    // 拷贝赋值，构造，拷贝构造，析构。   应该是调用拷贝赋值，然后 将临时对象 拷贝到 s2 中，然后析构 临时对象
    std::cout<<"1111"<<std::endl;

    s3 = std::move(s4);     // move operator=
    std::cout<<"222"<<std::endl;

    Spreadsheet s5 {std::move(s3)}; // move constructor
    std::cout<<"33"<<std::endl;

    // swap(s1, s2);

    SpreadsheetCell sc4 {1.1};
    std::cout<<sc4.getV2()<<std::endl;      // not tmp
    std::cout<<SpreadsheetCell(2.2).getV2()<<std::endl;     // tmp
    std::cout<<std::move(sc4).getV2()<<std::endl;       // tmp

    std::cout<<" ====== \n";

    std::cout<<s5.ms_counter<<" ---\n";
    // std::cout<<s5.ms_counter2<<" ===\n";
    std::cout<<s5.m_id<<" ..\n";        // s5的数据来源于s3, s3来源于s4, s4是通过 拷贝构造 来的，所以是 默认的 m_id。
    Spreadsheet s6 {123,444};
    std::cout<<s6.m_id<<" --\n";        // ok

    std::cout<<Spreadsheet::ms_counter<<" ??\n";
    std::cout<<s6.MaxHeight<<" .\n";

    std::cout<<static_cast<int>(s6.m_color)<<" ..\n";       // 必须强转

    SpreadsheetCell sc5 {23.23};
    SpreadsheetCell sc6 {100.001};
    SpreadsheetCell sc7 = sc5 + sc6;
    std::cout<<sc7.getValue()<<std::endl;
    std::cout<<sc5.getValue()<<std::endl;
    std::cout<<sc6.getValue()<<std::endl;
    // sc7 = sc5.operator +(sc6);
    // sc7 = sc5.operator + (400);     // 400作为参数，调用 单参数的 构造器，生成 SpreadsheetCell，然后 operator+ (SpreadsheetCell& )。 性能差， 最好 编写一个 operator+(double)
    std::cout<<sc7.getValue()<<std::endl;
    sc7 = sc5 + 123.3;
    std::cout<<sc7.getValue()<<std::endl;
    sc7 = 111 + sc5;
    std::cout<<sc7.getValue()<<std::endl;

    // sc7.getValue();      // [[nodiscard]]， 所以编译失败。

        // operator+(&) 和 operator+(&, &) 不能共存啊。
    // 有单参数的时候，我加一个 双参数，编译失败了。。
    // ISO C++ 认为有歧义，尽管第一个备选的最差类型转换要好于第二个备选的最差类型转换
    // 备选 1： ‘SpreadsheetCell@spreadsheet_cell operator+@spreadsheet_cell(const SpreadsheetCell@spreadsheet_cell&, const SpreadsheetCell@spreadsheet_cell&)’
    // 备选 2： ‘SpreadsheetCell@spreadsheet_cell SpreadsheetCell@spreadsheet_cell::operator+(const SpreadsheetCell@spreadsheet_cell&) const’


    return 0;
}




