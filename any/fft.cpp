

#include <iostream>


// 看图能理解，就是通过 sin,cos的图像的叠加 来 模拟信号。
// 但是，其他就完全不知道了。包括 用来干吗？给定一个信号，怎么求 傅里叶 的 各个cos，sin 的 系数？ sin,cos 和 e^i2pinx/T 有什么关系？


/*

前提：任意的 (周期)图像都可以用 N 个 sin，cos的图像叠加。  这个只能看gif，当作公理来看了。经验派。不过无所谓，拉格朗日认为：不能当作N个sin/cos的叠加。

图我是从下面的网址看的， 主要就是看 gif， 特别是第一个，在 前一个 圆的 基础上 再画一个 圆， 然后再画一个圆。。
还有就是 中间的3张图，每张都是 N 从 1-50, 代表了 N个 sin/cos 的图像的 叠加，N 越大， 图像越和 周期函数接近。
https://baijiahao.baidu.com/s?id=1636833728798493906&wfr=spider&for=pc




然后参考 下面的 "马同学" 的回答
https://www.zhihu.com/question/21665935/answer/2367861632
我们已经 知道/认同 周期图像/周期函数 可以通过 N个 sin cos 函数来叠加。
所以 我们假设 f(x) 是 周期 T 的函数，所以 f(x)可以写成
f(x) = a0 * cos() + b0 * sin() + a1 * cos() + b1 * sin() + a2*cos() + b2*sin() + a3*cos() + b3*sin() + ....

f(x) 的周期是 T， 我们知道 sin,cos 的周期是 2*pi
。。这个公式 有2个问题， 为什么除以T， 为什么是 里面 乘以 2pi*n
除以 T 是因为 f(x) 的周期是 T， 所以 sin，cos 里的 参数 需要 以 T 为周期。。 也不对。 就这样理解吧。。就当作，周期为T，所以 每隔 T 距离就要 重置一次。 但是为什么不是 取模？ ==诶？把 /T 改成 %T 会是什么图像？== 。。
。!! 因为 cos，sin 自带周期， 所以 ==除以T 就可以 控制 周期的 大小==。 对，这个理由。 比如 sin(x)， 从0-2pi 就是一周期， 如果是 sin(x/2),那么一个周期 就需要 0-4pi 了。

然后呢，f(x) 的x 的取值 基本就是 1,2,3,4,  自然数， 所以 sin(x) 里面 x 就需要修改成 pi， 所以变成了 sin( 2pi * x )
。。为什么是 2pi ？
。要和 T 联系起来， 我们上面除以 T，是为了 控制 周期的大小。 那么 除以T， 会导致 周期*T 。 左侧 f(x)的周期 是T， 右侧表达式 由于 都 除以了T，所以 周期是 原周期*T。  所以 T = 原周期*T， 所以 原周期 就是 1 。
所以 sin，cos 的周期 要变成1, 即 x 取 1的时候 就完成了 第一个周期。
sin() 完成第一个周期 是 2pi，  所以 x 要乘以 2pi， 才能 在 x取1 的时候 就完成 一个周期。
。实际上，应该是： x取值1 代表了 sin的一个周期， 所以 x要乘以 2pi， 然后 为了 从周期1 变成 周期T，所以 除以了 T。 但是为什么 x取1就代表一个周期？


还有一个问题就是 n的取值，导致 cos，sin 是 0, 2pi, 4pi, 6pi, 8pi 的。 为什么？  为什么不是 0,pi,2pi,3pi,4pi
感觉还是 和 2pi 一个周期 有关，但是 只是 感觉。  T 要控制周期的大小， 那么 你得一个完整的周期啊， pi 是半个周期， 除以T 没有意义. 是这样吗？

anyway, 通过 傅里叶级数 模拟 f(x) 的公式：
f(x) = a0 * cos(2pi * 0 / T * x) + b0 * sin(2pi * 0 / T * x) + a1*cos(2pi * x / T) + b1*sin(2pi * x / T) + a2*cos(2pi*2*x/T) + b2*cos(4pi*x/T) + ...
= a0 + a1*cos(2pi * x / T) + b1*sin(2pi * x / T) + a2 * cos(4pi * x / T) + b2 * sin(4pi * x / T) + ...
= a0 + 连加{ an * cos(2pi * n * x / T) + bn * sin(2pi * n * x / T), n是1,2,3,4... }


周期T为2pi，的方波 f(x), 图像是 x取值0-pi 时，是y=2线段， x取pi-2pi是y=0的线段， 然后 开始周期。
通过 傅里叶就可以获得
n取1时，f(x) ~= 1 + 4*sin(x)/pi

计算步骤
1. T是2pi，n取1,所以变成了  a0 + a1*cos(x) + b1*sin(x)
2. 。。然后就不知道了。。感觉是 ==最小二乘法==。 。。 不过 要用 ==偏导+矩阵==。。我。。。。但是如果按照 我写的代码中 从最高项开始算，倒是可以。
1. a1,b1设置为0,那么就变成了 f(x)=a0 , 通过 最小方差， 可以得到 a0=1的。 因为 方波 是 y=2,y=0 交替，那么 中间值就是 y=1，所以 a0 就取 1
2. f(x) = 1 + a1*cos(x) + b1*sin(x) 。  这里只能 瞪眼法了。。。 我不知道 最小方差 可以算出 a1,b1吗。。由图像可以看出 a1=0, b1 != 0。
    。不，也可以， f(x)-1 = a1*cos(x) + b1*sin(x)， 由于图像 过 原点， 所以 a1=0, b1 != 0。 对 代入， 把 原点代入。
    。所以变成了 f(x)-1 = b1*sin(x)，  这里可以 最小二乘法了， 因为只有一个 未知项了， 而且不会受到干扰。
    。。这是 4/pi 也只是 为了图像 被 y=2,y=0 相交 所 设置的吧。 还是 怎么算的？ 我只知道 最小二乘 大约可以 算出一个值。
    。。。不不不，就是 标准的 最小二乘， 2个未知系数， 偏导，矩阵， 应该能算出来， 甚至 a0 也可以当作 未知 来 进行 最小二乘吧。

然后 n 增大， 图像就 越来越像了。 但是 没有说，这些 cos，sin的 系数是 怎么计算的。


举了一个 非周期的 函数， 这个 应该看不懂了。。。
非周期函数： x取0-pi，y=2,  先取-pi-0,y=0， x的取值返回就是 -pi - pi， 所以不是周期的
页面上的意思是，自己增加周期， 当作周期函数计算。

然后就不知道了， 看图是进行了拉伸， 但是 这个图 的 拉伸 好像 和我想的不太一样。。 怎么 x正轴 是 拉伸的 y=0,而不是 拉伸 y=2 。
。。而且感觉 拉伸也无所谓吧，  函数 是需要 定义域的， 定义域限定为 -pi - pi 就可以了啊。  当然，可以 稍微拉伸一点点，这样 可以让 -pi, pi 的 地方 是 一条直线，而不是 很多 弦。



傅里叶级数是
f(x) = a0 + 连加 { an * cos(2pi *n *x / T) + bn * sin(2pi *n *x / T), n=1,2,3,...}

通过欧拉公式，修改为 复数的形式
f(x) = 连加 { cn * e^(i * (2pi *n *x) / T) , n是 负无穷大 到 正无穷大}
其中， cn = 1/T * 积分{ f(x) * e^(-i * 2pi * n * x / T) , dx 范围 x0 - x0+T }

后面就不会了。


。。不过 既然 cn 可以 有公式， 那么 an, bn 有 直接的公式吗？
。。而且 cn的公式 怎么来的？
。。根据下面的欧拉公式  e^(ix) = cos(x) + i*sin(x)
e^(i * (2pi *n *x) / T) = cos(i * 2pi *n *x / T) + i * sin(i * 2pi *n *x / T)



F(w) = 1/2pi * 积分 [负无穷大，无穷大] { f(x) * e^(-iwx) , dx }
F(w) 就是 傅里叶变换， 得到的就是 ==频域曲线==。
。。频域就是 a0,a1, 的值 作为 y轴值， 0,1作为x轴值 。 不过  不太清楚 如果 b不为0 会怎么样。。 就是 傅里叶变化 怎么知道 b 是否全部为0？


==傅立叶变换就是，让 T=无穷大 ，求出上面这根频域曲线。==





---

傅里叶级数是一种三角级数，傅里叶级数也常称为三角级数

---


欧拉公式

https://zhuanlan.zhihu.com/p/516418015
从： 7.12更新 开始

y=a^x 求导 是 y'=a^x * lna

所以 y=e^x 求导 y' = e^x * lne = e^x

f(x) = x^100 求导后 会变成 f'(x) = 100 * x^99
所以求100次导后 变成了 y = x * 100!
为了保持 系数不变，所以 需要 除以 100!  所以 f(x) = x/100!

所以构造了 唯一符合条件的 多项式
e^x = x^0/0! + x^1/1! + x^2/2! ...

。。就是这个 多项式 满足 求导后 等于它 自身， 这个特性 和 e^x 一样。
。。值真的相同哦。。  满足 求导后等于它自身， 就可以 得到 近似表达式， 。。。

求道后等于它自身是这样的：
x^0 = 1, 0!=1, 所以 x^0/0! 是1,常数， 求导后 就成了 0
x^1/1! ,求导后 变成了 1*x^0/1! , 就是 第一项。  所以 删除第一个， 每个 向前一位， 由于是 无限序列，所以 求导后 等于 求导前。


这也是 e^x 的 泰勒级数展开。

若 x=1,则
e = 1 + 1/1! + 1/2! + 1/3! + ...
。。后续内容 和 我要的不同了，所以 可以不看了。


证明 e^(ix) = cos(x) + isin(x)
https://upimg.baike.so.com/doc/5392605-5629445.html

因为：
e^x = 1 + x/1! + x^2/2! + ..
cos(x) = 1 - x^2/2! + x^4/4! - x^6/6! + ...     // 这个是 泰勒展开。。。。
sin(x) = 1 - x^3/3! + x^5/5! - x^7/7! + ...

将 e^x 的展开式 中的 x 替换为 ±ix
    (±ix)^2 = -1, (±ix)^3 = ∓i, (±ix)^4=1

e^(±ix) = 1 ±ix/1! - x^2/2! ∓ ix^3/3! + x^4/4! ...
= (1 - x^2/2! + ..) ± i*(x - x^3/3! ...)

所以 e^(±ix) = cos(x) ± i*sin(x)
所以 ==e^(ix) = cos(x) + i*sin(x)==,  e^(-ix) = cos(x) - i*sin(x)

两式相减 得到  e^(ix) - e^(-ix) = 2*i*sin(x), 所以 sin(x) = (e^(ix) - e^(-ix)) / 2i
想加， cos(x) = (e^(ix) + e^(-ix)) / 2

*/




/*

数学是真的抽象。

https://blog.csdn.net/kakiebu/article/details/131740440
FFT

FFT（Fast Fourier Transformation），中文名快速傅里叶变换，用来加速多项式乘法朴素高精度乘法时间 O(n^2) )，但FFT能 O(n log_2 n)的时间解决。


https://blog.csdn.net/qq_43038456/article/details/137434073
。快速傅里叶变换是计算离散傅里叶变换（DFT）的一种高效算法，并且是数字信号处理中最基本的算法之一。
。FFT的主要目的是减少计算DFT时所需要的乘法和加法操作的数量，从而加快处理速度。
FFT利用了DFT中的对称性和周期性，通过将DFT分解为较小的DFTs来提高效率。最常用的FFT算法是基于分治策略的Cooley-Tukey算法，它将一个N点的DFT分解为两个N/2点的DFTs。
。。所以 dft 需要很多的 加法 乘法，   fft是用来 加速 加法 乘法的，  所以 fft 和 ft 没有太大的关系， fft适用于 所有的 加法 乘法 ？  dft只是 加法 乘法 中的 一个 运算规则，

。。所以 计算机中 使用 fft 是为了 加速  (可能是矩阵运算，想不出其他的 需要大量 加法 乘法 的运算) ， 而不是 为了 dft ？  和 傅里叶变换 没有任何关系？

。。话说， 我还真不知道 AI，ML，DL 之类的 要 矩阵运算 干什么。。


https://www.php.cn/faq/657708.html
机器学习中矩阵运算和应用
- 线性回归
    用于建立变量之间的线性关系
    为了求解回归系数并进行预测，可以使用正规方程或梯度下降等方法进行 矩 阵 运 算
- 主成分分析（PCA）
    用于从高维数据集中提取最重要的特征
    PCA将原始数据映射到新的特征空间，这个映射过程涉及到对数据协方差 矩 阵 进行特征值分解
- 神经网络
    神经网络是一种模拟人脑神经元工作方式的机器学习模型
    在神经网络中，输入和权重被表示为矩阵，通过 矩 阵 乘 法 和非线性激活函数的组合来实现信息的传递和转换。
- 图像处理
    图像通常表示为像素值组成的 矩 阵 。通过对图像矩阵进行矩阵运算，可以实现各种图像处理任务，如图像滤波、边缘检测、图像增强等。常见的图像处理技术，如卷积神经网络，利用卷积操作对图像进行特征提取和分类。
- 推荐系统
    基于 矩 阵 运算的推荐系统常用于分析用户与物品之间的交互行为，并预测用户可能感兴趣的物品。通过将用户评分或行为记录表示为矩阵，可以使用矩阵分解等方法来推断用户和物品之间的隐藏特征





https://baijiahao.baidu.com/s?id=1784223922305636366&wfr=spider&for=pc
傅里叶变换及其在机器学习中的应用

信号处理
用于音频处理、图像分析和数据压缩等任务。
例如，在音频处理中，傅立叶变换有助于识别音频信号中存在的各种频率，从而实现语音识别、音乐分类和降噪等任务。
在图像分析中，傅里叶变换可用于从图像中提取纹理和图案信息。通过将图像转换为频域，可以更轻松地检测边缘、形状和其他视觉特征。这对于图像识别、对象检测和图像压缩等任务至关重要。

机器学习中的应用
时间序列分析
    在金融、医疗、天气预报等领域，时间序列数据非常丰富
    傅立叶变换可以通过分析时间序列数据的频率分量来帮助从时间序列数据中提取相关特征。这对于异常检测、趋势分析和预测等任务至关重要。
自然语言处理
    当文本数据表示为单词序列时，可以将其视为离散信号。通过应用傅里叶变换，可以在频域中分析文本数据，这在文本分类、情感分析和主题建模中都有应用。
特征工程
    特征工程是机器学习流程中的关键步骤。通过将数据转换到频域，可以提取在时域中可能难以捕获的有价值的特征。这可以带来更强大、更准确的机器学习模型。
卷积神经网络 (CNN)
    傅里叶变换可用于设计专门检测图像中某些频率分量的卷积滤波器。这可以提高 CNN 在图像分类和对象识别等任务中的性能。
数据增强
    数据增强是一种用于增加训练数据集大小的技术。在图像处理中，傅里叶变换可用于通过改变图像的频率分量来创建增强数据。这有助于提高机器学习模型的泛化性和鲁棒性。




https://blog.csdn.net/universsky2015/article/details/135793515
矩阵数乘的快速算法：快速傅里叶变换与矩阵乘法

传统的矩阵数乘算法时间复杂度为O(n^3)
在1965年，美国数学家James G. Cooley和Jeffrey W. Tukey提出了快速傅里叶变换(Fast Fourier Transform，FFT)算法，该算法将傅里叶变换的计算次数从O(n^2)降低到O(nlogn)，为计算机数字信号处理领域奠定了基础。
随后，在1969年，Ralph F. Gross和Peter Swarztrauber发表了

快 速 傅 里 叶 变 换 与 矩 阵 乘 法 的关系

，提出了快速傅里叶变换的矩阵表示，从而为矩阵数乘的快速算法奠定了基础。


---

回到
https://blog.csdn.net/kakiebu/article/details/131740440

多项式的系数表示法和点值表示法FFT其实是一个用O(n log_2 n)的时间将一个用系数表示的多项式转换成它的点值表示的算法
多项式的系数表示和点值表示可以互相转换


多项式乘法
有2个用系数表示的多项式，我们把它们相乘，设2个多项式分别是A(x),B(x)，我们要取 A 的每个系数 和 B的每个系数相乘， 那么 时间复杂度 O(n^2)

但是2个用 点值 表示的多项式 相乘，只需要 O(n)
设 2个点值 多项式 分别是
f(x) = {(x0, f(x0)), (x1, f(x1)), (x2, f(x2))...}
g(x) = {(x0, g(x0)), (x1, g(x1)), (x2, g(x2))...}
设乘积为 h(x)
h(x) = {(x0,f(x0)g(x0)), (x1, f(x1)g(x1)), (x2, f(x2)g(x2))...}

。。？
。多项式就当做是 A(x) = ax2 + bx + c, B(x) = mx2 + nx + p,
。A(x)B(x) = (ax2 + bx + c) * (mx2 + nx + p)      O(n^2)

。但是 点值表示。。。。。 点值表示 在我看来，就想 中学那种 给你一个 sin 的 角度 和 sin值 的 表格 那样。
就是 列举了 所有的 可能的 x取值， 预先计算出 y，  就是 算法里 那种 打表 。 用 编译期/编码 时间 换取 运行期时间
。。难度就是 怎么 列举所有的 x 取值。。
所以 确实 是 O(n),  只不过这里的 n 是 x 的可取值个数。  O(n^2) 的n 是 多项式的 项数。 应该是 O(n*m)，毕竟 A B 的 项数 不一定相等。
。所以 如果 要求的 精确度 不高，或 x取值个数 不多， 可以 点值。


- 突然感觉 高精度乘法 能 O(n) 解决一堆问题？
- 但是 朴素的 系数表示法 转 点值表示法的 算法还是 O(n^2) 的复杂操作
- 朴素 系数转点值 的算法 叫 DFT (离散傅里叶变换)， 点值转系数 叫 IDFT (离散傅里叶逆变换)
- 难道 高精度乘法 只能 O(n^2) ？

。。没有理解 系数 -> 点值 需要 O(n^2) 。。 不是 n 么？ 列举一遍 x 的取值 就可以了。
。。DFT 那里说了， 应该是 x的取值个数 * 项数  所以是 O(n^2) 。。 感觉 一般来说， x 的取值个数 是 远远大于 项数的吧， 而且 项数 一般 4以内吧，完全可以当作 常数的。 阿贝尔：《一元五次方程没有代数一般解》， 阿贝尔群，伽罗瓦域。
。。不是， 挺奇怪的， 我不知道 为什么要计算 xk^(n-1) 。  知道了， 这个是说 最高项 是 n-1 次，所以 对于每个 x 的取值， 都需要计算 x^0, x^1 ... x^(n-1) .. 不会真的 n 次项吧。 n次 上升的速度太快了。

。。而且 点值 转 多项式， 和 最小二乘  哪个精确度高？  这2个 都是 离散点 转成 函数 。


复平面
2+3i 就是 x轴2, y轴3
如果想象成 极坐标，就是 (sqrt(13), arctan(3/2)) 。 实际上没有这种表达方式
复数的模 就是 复数点 到 原点的距离。 |z| = aqrt(a^2 + b^2)
z=a+bi 的共轭复数 就是 a-bi

复数可以四则运算 (a+bi) * (c+di) = (ac - bd) + i(ad+bc)
复数相加，满足 平行四边形法则
复数相乘，(a1, Q1) * (a2, Q2) = (a1a2, Q1 + Q2)  即 模相乘，极角相加


---

DFT 离散傅里叶变换

==所有的 n 都默认为 2 的整数次幂==


对于 系数多项式 转点值，可以 随意取 n 个值 代入x，计算 xk^0, xk^1 ..xk^(n-1), 0<=k<n 。 这是 O(n^2)
。。n个x的值， xk有 n个项(0..n-1)。

其实可以代入一组神奇的 x， 代入后不用作这么多的次方运算。

如果我们代入一些x，使得 每个x 的若干次方 等于1, 我们就不需要 做全部的 次方运算了
正负1 可以， 正负i 也可以。

。。 这样的话 x 的取值范围 就很小了啊。  而且 i 就代表 函数 需要在 复数 下 有意义吧？ 话说，是不是 所有(绝大部分) 的 函数 都在 复数下有意义，只不过 一般情况下，定义域 是 实数。


以原点为圆心，画一个 半径为1 的 单位圆， 圆上所有的 点 经过若干次 次方后 都可以得到 1.

一般就 n 等分。 比如 n等于8, 时 取 1+0i, 1/sqrt(2) + 1i/sqrt(2), 0+i, -1/sqrt(2) + 1i/sqrt(2), -1 + 0i, ...

从(1,0) 开始，(1,0)是第0个，再 逆时针 取 7个，标记为 wnk (n是下标，k是上标) 。所以8个点 编号 分别是 w80,w81,w82,w83,w84,w85,w86,w87.

由复数相乘，的 模长相乘，极角相加，可以得到 (wn1)^k = wnk
wn1 称为 n次单位根， 而且 每个 w 都可以求出
wnk = cos(2pi * k / n) + i*sin(2pi*k/n)
。。共n个点， 第k个点 ， 所以每个点 是 2pi/n * k

。模是1, 角度是 2pi*k/n, 所以 实部是 cos(), 虚部 sin()

单位根的一些性质
wnk = w2n2k
证明： wnk = cos(2pi * k/n) + i*sin(2pi * k/n) = cos(2pi * 2k/2n) + i*sin(2pi * 2k/2n) = w2n2k
。。只要 n 和 k 的 系数比 不变， 都是相同的。

wn(k+n/2) = -wnk
wn(k+n/2) = cos(2pi * (k + n/2) / n) + i*sin(2pi * (k+n/2) / n)
= cos(2pi*k/n + n*pi/n) + i*sin(2pi*k/n + n*pi/n)
= cos(2pi*k/n + pi) + i*sin(2pi*k/n + pi)
。角度，从图形上看，就是 转了 180度。。象限， cos(x+pi) = -cos(x), sin(x+pi)=-sin(x) .. cos是1,2正，3,4负， sin是1,4正，23负。 所以 +pi， 都会导致 符号变化。
= -cos(2pi*k/n) + -i*sin(2pi*k/n) = -wnk

wn(k+n/2), wnk 关于 原点对称。


wn0 = wnn

---
FFT

虽然 DFT 弄出了很多 w 来作为 代入多项式 的 x 值

但是 代入进入 还是得进行 O(n^2) 的计算。

。。。而且， 取样， 不可能取的到 复数 的 样 啊。  x 可以取 复数， 但是 实际观测的值 它的x 不可能是 复数啊。
。。？？ 进行 多项式乘法， 我要 x=5 时的 多项式乘法 后的值， 没有办法给啊， 因为 点值 它是 复数。。


DFT 可以分治，所以就有了 FFT
设有多项式 A(x) = a0x^0 + a1x^1 + ... an-1 * x^(n-1)
根据下标的 奇偶 分为2部分
A(x) = (a0 + a2*x^2 + a4*x^4 + ... + an-2 * x^(n-2)) + (a1x + a3*x^3 + ... an-1 * x^(n-1))
== (a0 + a2*x^2 + a4*x^4 + ... + an-2 * x^(n-2)) + x * (a1 + a3*x^2 + .. + an-1 * x^(n-2))

设 A1(x), A2(x)
A1(x) = a0 + a2x + a4*x^2 + ... + an-2 * x^(n/2 - 1)
A2(x) = a1 + a3x + a5*x^2 + ... + an-1 * x^(n/2 - 1)

A(x) = A1(x^2) + x * A2(x^2)

设 k < n/2, 把 wnk 作为 x 代入 A(x)
A(wnk) = A1((wnk)^2) + wnk * A2((wnk)^2)
= A1(wn2k) + wnk * A2(wn2k)             // ? 为什么 wnk * wnk = wn2k  。。极坐标的模式， 相乘等于， 模相乘，角相加，所以等于 wn2k 。。 因为 wnk 的模 是1, 角度 是 2pi*k/n , 所以 相乘后， 模还是1, 角度就是 2pi*(2k)/n ， 就是 wn2k    .. 举例， 1*1=1, 模是1,角度是0+0 ，所以 还是1,  i*i=-1, 模是1, 角度是90+90 = 180, 就是 -1
= A1(w(n/2)k) + wnk * A2(w(n/2)k)


那么对于 A(wn(k+n/2)) 可以推导：
A(wn(k+n/2)) = A1(wn(2k+n)) + wn(k+n/2) * A2(wn(2k+n))
= A1(wn2k * wnn) - wnk * A2(wn2k * wnn)     // 2k+n -> 2k * n 还是 极坐标，下面的相乘就是 等于 wn(2k+n) 。 还用到了wn(k+n/2) = -wnk
= A1(wn2k) - wnk * A2(wn2k)     // wnn = wn0 = 1+0i = 1
= A1(w(n/2)k) - wnk * A2(w(n/2)k)       // w(n/2)k 的含义就是 圆分成 n/2 份， 从x正轴 逆时针， 取 k 份。


可以看到 A(wnk) 和 A(wn(k+n/2)) 除了 第二项的符号不同， 其他都是一样的。

所以 如果已经知道 A1(w(n/2)k) 和 A2(w(n/2)k) 的值，就可以 计算出 A(wnk) 和 A(wn(k+n/2))

这样就可以 递归 FFT

每一次回溯时只扫当前前面一半的序列，即可得出后面一半序列的答案
。。。？
k是 < n/2 的， 所以 A(wnk) + A(wn(k+n/2)) 才是完整的。 A(wnk) 和 A(wn(k+n/2)) 是类似的计算逻辑， 所以计算量/2 了。

。。原文有 代码，
。。 但是 还是 好抽象。


```C++
#include<complex>
#define cp complex<double>

void fft(cp *a,int n,int inv)
{
    int bit=0;
    while ((1<<bit)<n)bit++;
    fo(i,0,n-1)
    {
        rev[i]=(rev[i>>1]>>1)|((i&1)<<(bit-1));
        if (i<rev[i])swap(a[i],a[rev[i]]);//不加这条if会交换两次（就是没交换）
    }
    for (int mid=1;mid<n;mid*=2)//mid是准备合并序列的长度的二分之一
    {
    	cp temp(cos(pi/mid),inv*sin(pi/mid));//单位根，pi的系数2已经约掉了
        for (int i=0;i<n;i+=mid*2)//mid*2是准备合并序列的长度，i是合并到了哪一位
		{
            cp omega(1,0);
            for (int j=0;j<mid;j++,omega*=temp)//只扫左半部分，得到右半部分的答案
            {
                cp x=a[i+j],y=omega*a[i+j+mid];
                a[i+j]=x+y,a[i+j+mid]=x-y;//这个就是蝴蝶变换什么的
            }
        }
    }
}
```

怎么调用呢？ x 的取值怎么 设置呢？

没有 例子，很难想象啊。

或者说， 我有2个矩阵， 怎么用 fft 快速计算出 矩阵的 积 ？


// g



*/



// https://zhuanlan.zhihu.com/p/110897470?ivk_sa=1024320u&utm_id=0
// 这篇更猛， 数学太难啦。







int main()
{
    int x = 2;      // e^2
    double xx = x;
    std::cout<<(2.71828 * 2.71828)<<" vs. ";
    double d = 1;   // x0/0!
    double fact = 1;
    for (int i = 1; i < 20; ++i)
    {
        fact *= i;
        d += xx / fact;
        xx *= x;
    }
    std::cout<<d<<std::endl;
}




